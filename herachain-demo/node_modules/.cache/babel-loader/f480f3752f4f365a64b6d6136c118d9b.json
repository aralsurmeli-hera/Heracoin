{"ast":null,"code":"//! stable.js 0.1.8, https://github.com/Two-Screen/stable\n//! © 2018 Angry Bytes and contributors. MIT licensed.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.stable = factory();\n})(this, function () {\n  'use strict'; // A stable array sort, because `Array#sort()` is not guaranteed stable.\n  // This is an implementation of merge sort, without recursion.\n\n  var stable = function (arr, comp) {\n    return exec(arr.slice(), comp);\n  };\n\n  stable.inplace = function (arr, comp) {\n    var result = exec(arr, comp); // This simply copies back if the result isn't in the original array,\n    // which happens on an odd number of passes.\n\n    if (result !== arr) {\n      pass(result, null, arr.length, arr);\n    }\n\n    return arr;\n  }; // Execute the sort using the input array and a second buffer as work space.\n  // Returns one of those two, containing the final result.\n\n\n  function exec(arr, comp) {\n    if (typeof comp !== 'function') {\n      comp = function (a, b) {\n        return String(a).localeCompare(b);\n      };\n    } // Short-circuit when there's nothing to sort.\n\n\n    var len = arr.length;\n\n    if (len <= 1) {\n      return arr;\n    } // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.\n    // Chunks are the size of the left or right hand in merge sort.\n    // Stop when the left-hand covers all of the array.\n\n\n    var buffer = new Array(len);\n\n    for (var chk = 1; chk < len; chk *= 2) {\n      pass(arr, comp, chk, buffer);\n      var tmp = arr;\n      arr = buffer;\n      buffer = tmp;\n    }\n\n    return arr;\n  } // Run a single pass with the given chunk size.\n\n\n  var pass = function (arr, comp, chk, result) {\n    var len = arr.length;\n    var i = 0; // Step size / double chunk size.\n\n    var dbl = chk * 2; // Bounds of the left and right chunks.\n\n    var l, r, e; // Iterators over the left and right chunk.\n\n    var li, ri; // Iterate over pairs of chunks.\n\n    for (l = 0; l < len; l += dbl) {\n      r = l + chk;\n      e = r + chk;\n      if (r > len) r = len;\n      if (e > len) e = len; // Iterate both chunks in parallel.\n\n      li = l;\n      ri = r;\n\n      while (true) {\n        // Compare the chunks.\n        if (li < r && ri < e) {\n          // This works for a regular `sort()` compatible comparator,\n          // but also for a simple comparator like: `a > b`\n          if (comp(arr[li], arr[ri]) <= 0) {\n            result[i++] = arr[li++];\n          } else {\n            result[i++] = arr[ri++];\n          }\n        } // Nothing to compare, just flush what's left.\n        else if (li < r) {\n          result[i++] = arr[li++];\n        } else if (ri < e) {\n          result[i++] = arr[ri++];\n        } // Both iterators are at the chunk ends.\n        else {\n          break;\n        }\n      }\n    }\n  };\n\n  return stable;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","stable","arr","comp","exec","slice","inplace","result","pass","length","a","b","String","localeCompare","len","buffer","Array","chk","tmp","i","dbl","l","r","e","li","ri"],"sources":["/Users/austinhatch/Documents/GitHub/Heracoin/herachain-demo/node_modules/stable/stable.js"],"sourcesContent":["//! stable.js 0.1.8, https://github.com/Two-Screen/stable\n//! © 2018 Angry Bytes and contributors. MIT licensed.\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.stable = factory());\n}(this, (function () { 'use strict';\n\n  // A stable array sort, because `Array#sort()` is not guaranteed stable.\n  // This is an implementation of merge sort, without recursion.\n\n  var stable = function (arr, comp) {\n    return exec(arr.slice(), comp)\n  };\n\n  stable.inplace = function (arr, comp) {\n    var result = exec(arr, comp);\n\n    // This simply copies back if the result isn't in the original array,\n    // which happens on an odd number of passes.\n    if (result !== arr) {\n      pass(result, null, arr.length, arr);\n    }\n\n    return arr\n  };\n\n  // Execute the sort using the input array and a second buffer as work space.\n  // Returns one of those two, containing the final result.\n  function exec(arr, comp) {\n    if (typeof(comp) !== 'function') {\n      comp = function (a, b) {\n        return String(a).localeCompare(b)\n      };\n    }\n\n    // Short-circuit when there's nothing to sort.\n    var len = arr.length;\n    if (len <= 1) {\n      return arr\n    }\n\n    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.\n    // Chunks are the size of the left or right hand in merge sort.\n    // Stop when the left-hand covers all of the array.\n    var buffer = new Array(len);\n    for (var chk = 1; chk < len; chk *= 2) {\n      pass(arr, comp, chk, buffer);\n\n      var tmp = arr;\n      arr = buffer;\n      buffer = tmp;\n    }\n\n    return arr\n  }\n\n  // Run a single pass with the given chunk size.\n  var pass = function (arr, comp, chk, result) {\n    var len = arr.length;\n    var i = 0;\n    // Step size / double chunk size.\n    var dbl = chk * 2;\n    // Bounds of the left and right chunks.\n    var l, r, e;\n    // Iterators over the left and right chunk.\n    var li, ri;\n\n    // Iterate over pairs of chunks.\n    for (l = 0; l < len; l += dbl) {\n      r = l + chk;\n      e = r + chk;\n      if (r > len) r = len;\n      if (e > len) e = len;\n\n      // Iterate both chunks in parallel.\n      li = l;\n      ri = r;\n      while (true) {\n        // Compare the chunks.\n        if (li < r && ri < e) {\n          // This works for a regular `sort()` compatible comparator,\n          // but also for a simple comparator like: `a > b`\n          if (comp(arr[li], arr[ri]) <= 0) {\n            result[i++] = arr[li++];\n          }\n          else {\n            result[i++] = arr[ri++];\n          }\n        }\n        // Nothing to compare, just flush what's left.\n        else if (li < r) {\n          result[i++] = arr[li++];\n        }\n        else if (ri < e) {\n          result[i++] = arr[ri++];\n        }\n        // Both iterators are at the chunk ends.\n        else {\n          break\n        }\n      }\n    }\n  };\n\n  return stable;\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
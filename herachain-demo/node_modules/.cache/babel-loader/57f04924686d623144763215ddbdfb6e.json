{"ast":null,"code":"var tokenize = require('./tokenize');\n\nvar MAX_RANGE = 0x1FFFFFFF; // \"Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared \"packed\".\"\n// https://developers.google.com/protocol-buffers/docs/encoding#optional\n\nvar PACKABLE_TYPES = [// varint wire types\n'int32', 'int64', 'uint32', 'uint64', 'sint32', 'sint64', 'bool', // + ENUMS\n// 64-bit wire types\n'fixed64', 'sfixed64', 'double', // 32-bit wire types\n'fixed32', 'sfixed32', 'float'];\n\nvar onfieldoptionvalue = function (tokens) {\n  var value = tokens.shift();\n\n  if (value !== '{') {\n    return value;\n  }\n\n  value = {};\n  var field = '';\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '}':\n        tokens.shift();\n        return value;\n\n      case ':':\n        tokens.shift();\n        value[field] = onfieldoptionvalue(tokens);\n        break;\n\n      default:\n        field = tokens.shift();\n    }\n  }\n};\n\nvar onfieldoptions = function (tokens) {\n  var opts = {};\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '[':\n      case ',':\n        {\n          tokens.shift();\n          var name = tokens.shift();\n\n          if (name === '(') {\n            // handling [(A) = B]\n            name = tokens.shift();\n            tokens.shift(); // remove the end of bracket\n          }\n\n          var field = [];\n\n          if (tokens[0][0] === '.') {\n            field = tokens[0].substr(1).split('.');\n            tokens.shift();\n          }\n\n          if (tokens[0] !== '=') throw new Error('Unexpected token in field options: ' + tokens[0]);\n          tokens.shift();\n          if (tokens[0] === ']') throw new Error('Unexpected ] in field option'); // for option (A).b.c\n          // path will be ['A', 'b'] and lastFieldName 'c'\n\n          var path = [name].concat(field);\n          var lastFieldName = path.pop(); // opt references opts.A.b\n\n          var opt = path.reduce(function (opt, n, index) {\n            if (opt[n] == null) {\n              opt[n] = {};\n            }\n\n            return opt[n];\n          }, opts); // now set opt['c'] that references opts.A.b['c']\n\n          opt[lastFieldName] = onfieldoptionvalue(tokens);\n          break;\n        }\n\n      case ']':\n        tokens.shift();\n        return opts;\n\n      default:\n        throw new Error('Unexpected token in field options: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for field options');\n};\n\nvar onfield = function (tokens) {\n  var field = {\n    name: null,\n    type: null,\n    tag: -1,\n    map: null,\n    oneof: null,\n    required: false,\n    repeated: false,\n    options: {}\n  };\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '=':\n        tokens.shift();\n        field.tag = Number(tokens.shift());\n        break;\n\n      case 'map':\n        field.type = 'map';\n        field.map = {\n          from: null,\n          to: null\n        };\n        tokens.shift();\n        if (tokens[0] !== '<') throw new Error('Unexpected token in map type: ' + tokens[0]);\n        tokens.shift();\n        field.map.from = tokens.shift();\n        if (tokens[0] !== ',') throw new Error('Unexpected token in map type: ' + tokens[0]);\n        tokens.shift();\n        field.map.to = tokens.shift();\n        if (tokens[0] !== '>') throw new Error('Unexpected token in map type: ' + tokens[0]);\n        tokens.shift();\n        field.name = tokens.shift();\n        break;\n\n      case 'repeated':\n      case 'required':\n      case 'optional':\n        var t = tokens.shift();\n        field.required = t === 'required';\n        field.repeated = t === 'repeated';\n        field.type = tokens.shift();\n        field.name = tokens.shift();\n        break;\n\n      case '[':\n        field.options = onfieldoptions(tokens);\n        break;\n\n      case ';':\n        if (field.name === null) throw new Error('Missing field name');\n        if (field.type === null) throw new Error('Missing type in message field: ' + field.name);\n        if (field.tag === -1) throw new Error('Missing tag number in message field: ' + field.name);\n        tokens.shift();\n        return field;\n\n      default:\n        throw new Error('Unexpected token in message field: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No ; found for message field');\n};\n\nvar onmessagebody = function (tokens) {\n  var body = {\n    enums: [],\n    options: {},\n    messages: [],\n    fields: [],\n    extends: [],\n    extensions: null\n  };\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case 'map':\n      case 'repeated':\n      case 'optional':\n      case 'required':\n        body.fields.push(onfield(tokens));\n        break;\n\n      case 'enum':\n        body.enums.push(onenum(tokens));\n        break;\n\n      case 'message':\n        body.messages.push(onmessage(tokens));\n        break;\n\n      case 'extensions':\n        body.extensions = onextensions(tokens);\n        break;\n\n      case 'oneof':\n        tokens.shift();\n        var name = tokens.shift();\n        if (tokens[0] !== '{') throw new Error('Unexpected token in oneof: ' + tokens[0]);\n        tokens.shift();\n\n        while (tokens[0] !== '}') {\n          tokens.unshift('optional');\n          var field = onfield(tokens);\n          field.oneof = name;\n          body.fields.push(field);\n        }\n\n        tokens.shift();\n        break;\n\n      case 'extend':\n        body.extends.push(onextend(tokens));\n        break;\n\n      case ';':\n        tokens.shift();\n        break;\n\n      case 'reserved':\n        tokens.shift();\n\n        while (tokens[0] !== ';') {\n          tokens.shift();\n        }\n\n        break;\n\n      case 'option':\n        var opt = onoption(tokens);\n        if (body.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name);\n        body.options[opt.name] = opt.value;\n        break;\n\n      default:\n        // proto3 does not require the use of optional/required, assumed as optional\n        // \"singular: a well-formed message can have zero or one of this field (but not more than one).\"\n        // https://developers.google.com/protocol-buffers/docs/proto3#specifying-field-rules\n        tokens.unshift('optional');\n        body.fields.push(onfield(tokens));\n    }\n  }\n\n  return body;\n};\n\nvar onextend = function (tokens) {\n  var out = {\n    name: tokens[1],\n    message: onmessage(tokens)\n  };\n  return out;\n};\n\nvar onextensions = function (tokens) {\n  tokens.shift();\n  var from = Number(tokens.shift());\n  if (isNaN(from)) throw new Error('Invalid from in extensions definition');\n  if (tokens.shift() !== 'to') throw new Error(\"Expected keyword 'to' in extensions definition\");\n  var to = tokens.shift();\n  if (to === 'max') to = MAX_RANGE;\n  to = Number(to);\n  if (isNaN(to)) throw new Error('Invalid to in extensions definition');\n  if (tokens.shift() !== ';') throw new Error('Missing ; in extensions definition');\n  return {\n    from: from,\n    to: to\n  };\n};\n\nvar onmessage = function (tokens) {\n  tokens.shift();\n  var lvl = 1;\n  var body = [];\n  var msg = {\n    name: tokens.shift(),\n    options: {},\n    enums: [],\n    extends: [],\n    messages: [],\n    fields: []\n  };\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '{') lvl++;else if (tokens[0] === '}') lvl--;\n\n    if (!lvl) {\n      tokens.shift();\n      body = onmessagebody(body);\n      msg.enums = body.enums;\n      msg.messages = body.messages;\n      msg.fields = body.fields;\n      msg.extends = body.extends;\n      msg.extensions = body.extensions;\n      msg.options = body.options;\n      return msg;\n    }\n\n    body.push(tokens.shift());\n  }\n\n  if (lvl) throw new Error('No closing tag for message');\n};\n\nvar onpackagename = function (tokens) {\n  tokens.shift();\n  var name = tokens.shift();\n  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0]);\n  tokens.shift();\n  return name;\n};\n\nvar onsyntaxversion = function (tokens) {\n  tokens.shift();\n  if (tokens[0] !== '=') throw new Error('Expected = but found ' + tokens[0]);\n  tokens.shift();\n  var version = tokens.shift();\n\n  switch (version) {\n    case '\"proto2\"':\n      version = 2;\n      break;\n\n    case '\"proto3\"':\n      version = 3;\n      break;\n\n    default:\n      throw new Error('Expected protobuf syntax version but found ' + version);\n  }\n\n  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0]);\n  tokens.shift();\n  return version;\n};\n\nvar onenumvalue = function (tokens) {\n  if (tokens.length < 4) throw new Error('Invalid enum value: ' + tokens.slice(0, 3).join(' '));\n\n  if (tokens[0] === 'reserved') {\n    tokens.shift();\n\n    while (tokens[0] !== ';') {\n      tokens.shift();\n    }\n\n    tokens.shift();\n    return null;\n  }\n\n  if (tokens[1] !== '=') throw new Error('Expected = but found ' + tokens[1]);\n  if (tokens[3] !== ';' && tokens[3] !== '[') throw new Error('Expected ; or [ but found ' + tokens[1]);\n  var name = tokens.shift();\n  tokens.shift();\n  var val = {\n    value: null,\n    options: {}\n  };\n  val.value = Number(tokens.shift());\n\n  if (tokens[0] === '[') {\n    val.options = onfieldoptions(tokens);\n  }\n\n  tokens.shift(); // expecting the semicolon here\n\n  return {\n    name: name,\n    val: val\n  };\n};\n\nvar onenum = function (tokens) {\n  tokens.shift();\n  var options = {};\n  var e = {\n    name: tokens.shift(),\n    values: {},\n    options: {}\n  };\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift(); // there goes optional semicolon after the enclosing \"}\"\n\n      if (tokens[0] === ';') tokens.shift();\n      return e;\n    }\n\n    if (tokens[0] === 'option') {\n      options = onoption(tokens);\n      e.options[options.name] = options.value;\n      continue;\n    }\n\n    var val = onenumvalue(tokens);\n\n    if (val !== null) {\n      e.values[val.name] = val.val;\n    }\n  }\n\n  throw new Error('No closing tag for enum');\n};\n\nvar onoption = function (tokens) {\n  var name = null;\n  var value = null;\n\n  var parse = function (value) {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value.replace(/^\"+|\"+$/gm, '');\n  };\n\n  while (tokens.length) {\n    if (tokens[0] === ';') {\n      tokens.shift();\n      return {\n        name: name,\n        value: value\n      };\n    }\n\n    switch (tokens[0]) {\n      case 'option':\n        tokens.shift();\n        var hasBracket = tokens[0] === '(';\n        if (hasBracket) tokens.shift();\n        name = tokens.shift();\n\n        if (hasBracket) {\n          if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n          tokens.shift();\n        }\n\n        if (tokens[0][0] === '.') {\n          name += tokens.shift();\n        }\n\n        break;\n\n      case '=':\n        tokens.shift();\n        if (name === null) throw new Error('Expected key for option with value: ' + tokens[0]);\n        value = parse(tokens.shift());\n\n        if (name === 'optimize_for' && !/^(SPEED|CODE_SIZE|LITE_RUNTIME)$/.test(value)) {\n          throw new Error('Unexpected value for option optimize_for: ' + value);\n        } else if (value === '{') {\n          // option foo = {bar: baz}\n          value = onoptionMap(tokens);\n        }\n\n        break;\n\n      default:\n        throw new Error('Unexpected token in option: ' + tokens[0]);\n    }\n  }\n};\n\nvar onoptionMap = function (tokens) {\n  var parse = function (value) {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value.replace(/^\"+|\"+$/gm, '');\n  };\n\n  var map = {};\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift();\n      return map;\n    }\n\n    var hasBracket = tokens[0] === '(';\n    if (hasBracket) tokens.shift();\n    var key = tokens.shift();\n\n    if (hasBracket) {\n      if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n      tokens.shift();\n    }\n\n    var value = null;\n\n    switch (tokens[0]) {\n      case ':':\n        if (map[key] !== undefined) throw new Error('Duplicate option map key ' + key);\n        tokens.shift();\n        value = parse(tokens.shift());\n\n        if (value === '{') {\n          // option foo = {bar: baz}\n          value = onoptionMap(tokens);\n        }\n\n        map[key] = value;\n\n        if (tokens[0] === ';') {\n          tokens.shift();\n        }\n\n        break;\n\n      case '{':\n        tokens.shift();\n        value = onoptionMap(tokens);\n        if (map[key] === undefined) map[key] = [];\n        if (!Array.isArray(map[key])) throw new Error('Duplicate option map key ' + key);\n        map[key].push(value);\n        break;\n\n      default:\n        throw new Error('Unexpected token in option map: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for option map');\n};\n\nvar onimport = function (tokens) {\n  tokens.shift();\n  var file = tokens.shift().replace(/^\"+|\"+$/gm, '');\n  if (tokens[0] !== ';') throw new Error('Unexpected token: ' + tokens[0] + '. Expected \";\"');\n  tokens.shift();\n  return file;\n};\n\nvar onservice = function (tokens) {\n  tokens.shift();\n  var service = {\n    name: tokens.shift(),\n    methods: [],\n    options: {}\n  };\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift(); // there goes optional semicolon after the enclosing \"}\"\n\n      if (tokens[0] === ';') tokens.shift();\n      return service;\n    }\n\n    switch (tokens[0]) {\n      case 'option':\n        var opt = onoption(tokens);\n        if (service.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name);\n        service.options[opt.name] = opt.value;\n        break;\n\n      case 'rpc':\n        service.methods.push(onrpc(tokens));\n        break;\n\n      default:\n        throw new Error('Unexpected token in service: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for service');\n};\n\nvar onrpc = function (tokens) {\n  tokens.shift();\n  var rpc = {\n    name: tokens.shift(),\n    input_type: null,\n    output_type: null,\n    client_streaming: false,\n    server_streaming: false,\n    options: {}\n  };\n  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0]);\n  tokens.shift();\n\n  if (tokens[0] === 'stream') {\n    tokens.shift();\n    rpc.client_streaming = true;\n  }\n\n  rpc.input_type = tokens.shift();\n  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n  tokens.shift();\n  if (tokens[0] !== 'returns') throw new Error('Expected returns but found ' + tokens[0]);\n  tokens.shift();\n  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0]);\n  tokens.shift();\n\n  if (tokens[0] === 'stream') {\n    tokens.shift();\n    rpc.server_streaming = true;\n  }\n\n  rpc.output_type = tokens.shift();\n  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n  tokens.shift();\n\n  if (tokens[0] === ';') {\n    tokens.shift();\n    return rpc;\n  }\n\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift(); // there goes optional semicolon after the enclosing \"}\"\n\n      if (tokens[0] === ';') tokens.shift();\n      return rpc;\n    }\n\n    if (tokens[0] === 'option') {\n      var opt = onoption(tokens);\n      if (rpc.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name);\n      rpc.options[opt.name] = opt.value;\n    } else {\n      throw new Error('Unexpected token in rpc options: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for rpc');\n};\n\nvar parse = function (buf) {\n  var tokens = tokenize(buf.toString()); // check for isolated strings in tokens by looking for opening quote\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (/^(\"|')([^'\"]*)$/.test(tokens[i])) {\n      var j;\n\n      if (tokens[i].length === 1) {\n        j = i + 1;\n      } else {\n        j = i;\n      } // look ahead for the closing quote and collapse all\n      // in-between tokens into a single token\n\n\n      for (j; j < tokens.length; j++) {\n        if (/^[^'\"\\\\]*(?:\\\\.[^'\"\\\\]*)*(\"|')$/.test(tokens[j])) {\n          tokens = tokens.slice(0, i).concat(tokens.slice(i, j + 1).join('')).concat(tokens.slice(j + 1));\n          break;\n        }\n      }\n    }\n  }\n\n  var schema = {\n    syntax: 3,\n    package: null,\n    imports: [],\n    enums: [],\n    messages: [],\n    options: {},\n    extends: []\n  };\n  var firstline = true;\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case 'package':\n        schema.package = onpackagename(tokens);\n        break;\n\n      case 'syntax':\n        if (!firstline) throw new Error('Protobuf syntax version should be first thing in file');\n        schema.syntax = onsyntaxversion(tokens);\n        break;\n\n      case 'message':\n        schema.messages.push(onmessage(tokens));\n        break;\n\n      case 'enum':\n        schema.enums.push(onenum(tokens));\n        break;\n\n      case 'option':\n        var opt = onoption(tokens);\n        if (schema.options[opt.name]) throw new Error('Duplicate option ' + opt.name);\n        schema.options[opt.name] = opt.value;\n        break;\n\n      case 'import':\n        schema.imports.push(onimport(tokens));\n        break;\n\n      case 'extend':\n        schema.extends.push(onextend(tokens));\n        break;\n\n      case 'service':\n        if (!schema.services) schema.services = [];\n        schema.services.push(onservice(tokens));\n        break;\n\n      default:\n        throw new Error('Unexpected token: ' + tokens[0]);\n    }\n\n    firstline = false;\n  } // now iterate over messages and propagate extends\n\n\n  schema.extends.forEach(function (ext) {\n    schema.messages.forEach(function (msg) {\n      if (msg.name === ext.name) {\n        ext.message.fields.forEach(function (field) {\n          if (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to) {\n            throw new Error(msg.name + ' does not declare ' + field.tag + ' as an extension number');\n          }\n\n          msg.fields.push(field);\n        });\n      }\n    });\n  });\n  schema.messages.forEach(function (msg) {\n    msg.fields.forEach(function (field) {\n      var fieldSplit;\n      var messageName;\n      var nestedEnumName;\n      var message;\n\n      function enumNameIsFieldType(en) {\n        return en.name === field.type;\n      }\n\n      function enumNameIsNestedEnumName(en) {\n        return en.name === nestedEnumName;\n      }\n\n      if (field.options && field.options.packed === 'true') {\n        if (PACKABLE_TYPES.indexOf(field.type) === -1) {\n          // let's see if it's an enum\n          if (field.type.indexOf('.') === -1) {\n            if (msg.enums && msg.enums.some(enumNameIsFieldType)) {\n              return;\n            }\n          } else {\n            fieldSplit = field.type.split('.');\n\n            if (fieldSplit.length > 2) {\n              throw new Error('what is this?');\n            }\n\n            messageName = fieldSplit[0];\n            nestedEnumName = fieldSplit[1];\n            schema.messages.some(function (msg) {\n              if (msg.name === messageName) {\n                message = msg;\n                return msg;\n              }\n            });\n\n            if (message && message.enums && message.enums.some(enumNameIsNestedEnumName)) {\n              return;\n            }\n          }\n\n          throw new Error('Fields of type ' + field.type + ' cannot be declared [packed=true]. ' + 'Only repeated fields of primitive numeric types (types which use ' + 'the varint, 32-bit, or 64-bit wire types) can be declared \"packed\". ' + 'See https://developers.google.com/protocol-buffers/docs/encoding#optional');\n        }\n      }\n    });\n  });\n  return schema;\n};\n\nmodule.exports = parse;","map":{"version":3,"names":["tokenize","require","MAX_RANGE","PACKABLE_TYPES","onfieldoptionvalue","tokens","value","shift","field","length","onfieldoptions","opts","name","substr","split","Error","path","concat","lastFieldName","pop","opt","reduce","n","index","onfield","type","tag","map","oneof","required","repeated","options","Number","from","to","t","onmessagebody","body","enums","messages","fields","extends","extensions","push","onenum","onmessage","onextensions","unshift","onextend","onoption","undefined","out","message","isNaN","lvl","msg","onpackagename","onsyntaxversion","version","onenumvalue","slice","join","val","e","values","parse","replace","hasBracket","test","onoptionMap","key","Array","isArray","onimport","file","onservice","service","methods","onrpc","rpc","input_type","output_type","client_streaming","server_streaming","buf","toString","i","j","schema","syntax","package","imports","firstline","services","forEach","ext","fieldSplit","messageName","nestedEnumName","enumNameIsFieldType","en","enumNameIsNestedEnumName","packed","indexOf","some","module","exports"],"sources":["/Users/austinhatch/Documents/GitHub/Heracoin/herachain-demo/node_modules/protocol-buffers-schema/parse.js"],"sourcesContent":["var tokenize = require('./tokenize')\nvar MAX_RANGE = 0x1FFFFFFF\n\n// \"Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared \"packed\".\"\n// https://developers.google.com/protocol-buffers/docs/encoding#optional\nvar PACKABLE_TYPES = [\n  // varint wire types\n  'int32', 'int64', 'uint32', 'uint64', 'sint32', 'sint64', 'bool',\n  // + ENUMS\n  // 64-bit wire types\n  'fixed64', 'sfixed64', 'double',\n  // 32-bit wire types\n  'fixed32', 'sfixed32', 'float'\n]\n\nvar onfieldoptionvalue = function (tokens) {\n  var value = tokens.shift()\n  if (value !== '{') {\n    return value\n  }\n  value = {}\n  var field = ''\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '}':\n        tokens.shift()\n        return value\n      case ':':\n        tokens.shift()\n        value[field] = onfieldoptionvalue(tokens)\n        break\n      default:\n        field = tokens.shift()\n    }\n  }\n}\n\nvar onfieldoptions = function (tokens) {\n  var opts = {}\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '[':\n      case ',': {\n        tokens.shift()\n        var name = tokens.shift()\n        if (name === '(') { // handling [(A) = B]\n          name = tokens.shift()\n          tokens.shift() // remove the end of bracket\n        }\n        var field = []\n        if (tokens[0][0] === '.') {\n          field = tokens[0].substr(1).split('.')\n          tokens.shift()\n        }\n        if (tokens[0] !== '=') throw new Error('Unexpected token in field options: ' + tokens[0])\n        tokens.shift()\n        if (tokens[0] === ']') throw new Error('Unexpected ] in field option')\n\n        // for option (A).b.c\n        // path will be ['A', 'b'] and lastFieldName 'c'\n        var path = [name].concat(field)\n        var lastFieldName = path.pop()\n\n        // opt references opts.A.b\n        var opt = path.reduce(function (opt, n, index) {\n          if (opt[n] == null) {\n            opt[n] = {}\n          }\n          return opt[n]\n        }, opts)\n\n        // now set opt['c'] that references opts.A.b['c']\n        opt[lastFieldName] = onfieldoptionvalue(tokens)\n        break\n      }\n      case ']':\n        tokens.shift()\n        return opts\n\n      default:\n        throw new Error('Unexpected token in field options: ' + tokens[0])\n    }\n  }\n\n  throw new Error('No closing tag for field options')\n}\n\nvar onfield = function (tokens) {\n  var field = {\n    name: null,\n    type: null,\n    tag: -1,\n    map: null,\n    oneof: null,\n    required: false,\n    repeated: false,\n    options: {}\n  }\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '=':\n        tokens.shift()\n        field.tag = Number(tokens.shift())\n        break\n\n      case 'map':\n        field.type = 'map'\n        field.map = { from: null, to: null }\n        tokens.shift()\n        if (tokens[0] !== '<') throw new Error('Unexpected token in map type: ' + tokens[0])\n        tokens.shift()\n        field.map.from = tokens.shift()\n        if (tokens[0] !== ',') throw new Error('Unexpected token in map type: ' + tokens[0])\n        tokens.shift()\n        field.map.to = tokens.shift()\n        if (tokens[0] !== '>') throw new Error('Unexpected token in map type: ' + tokens[0])\n        tokens.shift()\n        field.name = tokens.shift()\n        break\n\n      case 'repeated':\n      case 'required':\n      case 'optional':\n        var t = tokens.shift()\n        field.required = t === 'required'\n        field.repeated = t === 'repeated'\n        field.type = tokens.shift()\n        field.name = tokens.shift()\n        break\n\n      case '[':\n        field.options = onfieldoptions(tokens)\n        break\n\n      case ';':\n        if (field.name === null) throw new Error('Missing field name')\n        if (field.type === null) throw new Error('Missing type in message field: ' + field.name)\n        if (field.tag === -1) throw new Error('Missing tag number in message field: ' + field.name)\n        tokens.shift()\n        return field\n\n      default:\n        throw new Error('Unexpected token in message field: ' + tokens[0])\n    }\n  }\n\n  throw new Error('No ; found for message field')\n}\n\nvar onmessagebody = function (tokens) {\n  var body = {\n    enums: [],\n    options: {},\n    messages: [],\n    fields: [],\n    extends: [],\n    extensions: null\n  }\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case 'map':\n      case 'repeated':\n      case 'optional':\n      case 'required':\n        body.fields.push(onfield(tokens))\n        break\n\n      case 'enum':\n        body.enums.push(onenum(tokens))\n        break\n\n      case 'message':\n        body.messages.push(onmessage(tokens))\n        break\n\n      case 'extensions':\n        body.extensions = onextensions(tokens)\n        break\n\n      case 'oneof':\n        tokens.shift()\n        var name = tokens.shift()\n        if (tokens[0] !== '{') throw new Error('Unexpected token in oneof: ' + tokens[0])\n        tokens.shift()\n        while (tokens[0] !== '}') {\n          tokens.unshift('optional')\n          var field = onfield(tokens)\n          field.oneof = name\n          body.fields.push(field)\n        }\n        tokens.shift()\n        break\n\n      case 'extend':\n        body.extends.push(onextend(tokens))\n        break\n\n      case ';':\n        tokens.shift()\n        break\n\n      case 'reserved':\n        tokens.shift()\n        while (tokens[0] !== ';') {\n          tokens.shift()\n        }\n        break\n\n      case 'option':\n        var opt = onoption(tokens)\n        if (body.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name)\n        body.options[opt.name] = opt.value\n        break\n\n      default:\n        // proto3 does not require the use of optional/required, assumed as optional\n        // \"singular: a well-formed message can have zero or one of this field (but not more than one).\"\n        // https://developers.google.com/protocol-buffers/docs/proto3#specifying-field-rules\n        tokens.unshift('optional')\n        body.fields.push(onfield(tokens))\n    }\n  }\n\n  return body\n}\n\nvar onextend = function (tokens) {\n  var out = {\n    name: tokens[1],\n    message: onmessage(tokens)\n  }\n  return out\n}\n\nvar onextensions = function (tokens) {\n  tokens.shift()\n  var from = Number(tokens.shift())\n  if (isNaN(from)) throw new Error('Invalid from in extensions definition')\n  if (tokens.shift() !== 'to') throw new Error(\"Expected keyword 'to' in extensions definition\")\n  var to = tokens.shift()\n  if (to === 'max') to = MAX_RANGE\n  to = Number(to)\n  if (isNaN(to)) throw new Error('Invalid to in extensions definition')\n  if (tokens.shift() !== ';') throw new Error('Missing ; in extensions definition')\n  return { from: from, to: to }\n}\nvar onmessage = function (tokens) {\n  tokens.shift()\n\n  var lvl = 1\n  var body = []\n  var msg = {\n    name: tokens.shift(),\n    options: {},\n    enums: [],\n    extends: [],\n    messages: [],\n    fields: []\n  }\n\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])\n  tokens.shift()\n\n  while (tokens.length) {\n    if (tokens[0] === '{') lvl++\n    else if (tokens[0] === '}') lvl--\n\n    if (!lvl) {\n      tokens.shift()\n      body = onmessagebody(body)\n      msg.enums = body.enums\n      msg.messages = body.messages\n      msg.fields = body.fields\n      msg.extends = body.extends\n      msg.extensions = body.extensions\n      msg.options = body.options\n      return msg\n    }\n\n    body.push(tokens.shift())\n  }\n\n  if (lvl) throw new Error('No closing tag for message')\n}\n\nvar onpackagename = function (tokens) {\n  tokens.shift()\n  var name = tokens.shift()\n  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0])\n  tokens.shift()\n  return name\n}\n\nvar onsyntaxversion = function (tokens) {\n  tokens.shift()\n\n  if (tokens[0] !== '=') throw new Error('Expected = but found ' + tokens[0])\n  tokens.shift()\n\n  var version = tokens.shift()\n  switch (version) {\n    case '\"proto2\"':\n      version = 2\n      break\n\n    case '\"proto3\"':\n      version = 3\n      break\n\n    default:\n      throw new Error('Expected protobuf syntax version but found ' + version)\n  }\n\n  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0])\n  tokens.shift()\n\n  return version\n}\n\nvar onenumvalue = function (tokens) {\n  if (tokens.length < 4) throw new Error('Invalid enum value: ' + tokens.slice(0, 3).join(' '))\n  if (tokens[0] === 'reserved') {\n    tokens.shift()\n    while (tokens[0] !== ';') {\n      tokens.shift()\n    }\n    tokens.shift()\n    return null\n  }\n  if (tokens[1] !== '=') throw new Error('Expected = but found ' + tokens[1])\n  if (tokens[3] !== ';' && tokens[3] !== '[') throw new Error('Expected ; or [ but found ' + tokens[1])\n\n  var name = tokens.shift()\n  tokens.shift()\n  var val = {\n    value: null,\n    options: {}\n  }\n  val.value = Number(tokens.shift())\n  if (tokens[0] === '[') {\n    val.options = onfieldoptions(tokens)\n  }\n  tokens.shift() // expecting the semicolon here\n\n  return {\n    name: name,\n    val: val\n  }\n}\n\nvar onenum = function (tokens) {\n  tokens.shift()\n  var options = {}\n  var e = {\n    name: tokens.shift(),\n    values: {},\n    options: {}\n  }\n\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])\n  tokens.shift()\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift()\n      // there goes optional semicolon after the enclosing \"}\"\n      if (tokens[0] === ';') tokens.shift()\n      return e\n    }\n    if (tokens[0] === 'option') {\n      options = onoption(tokens)\n      e.options[options.name] = options.value\n      continue\n    }\n    var val = onenumvalue(tokens)\n    if (val !== null) {\n      e.values[val.name] = val.val\n    }\n  }\n\n  throw new Error('No closing tag for enum')\n}\n\nvar onoption = function (tokens) {\n  var name = null\n  var value = null\n\n  var parse = function (value) {\n    if (value === 'true') return true\n    if (value === 'false') return false\n    return value.replace(/^\"+|\"+$/gm, '')\n  }\n\n  while (tokens.length) {\n    if (tokens[0] === ';') {\n      tokens.shift()\n      return { name: name, value: value }\n    }\n    switch (tokens[0]) {\n      case 'option':\n        tokens.shift()\n\n        var hasBracket = tokens[0] === '('\n        if (hasBracket) tokens.shift()\n\n        name = tokens.shift()\n\n        if (hasBracket) {\n          if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])\n          tokens.shift()\n        }\n\n        if (tokens[0][0] === '.') {\n          name += tokens.shift()\n        }\n\n        break\n\n      case '=':\n        tokens.shift()\n        if (name === null) throw new Error('Expected key for option with value: ' + tokens[0])\n        value = parse(tokens.shift())\n\n        if (name === 'optimize_for' && !/^(SPEED|CODE_SIZE|LITE_RUNTIME)$/.test(value)) {\n          throw new Error('Unexpected value for option optimize_for: ' + value)\n        } else if (value === '{') {\n          // option foo = {bar: baz}\n          value = onoptionMap(tokens)\n        }\n        break\n\n      default:\n        throw new Error('Unexpected token in option: ' + tokens[0])\n    }\n  }\n}\n\nvar onoptionMap = function (tokens) {\n  var parse = function (value) {\n    if (value === 'true') return true\n    if (value === 'false') return false\n    return value.replace(/^\"+|\"+$/gm, '')\n  }\n\n  var map = {}\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift()\n      return map\n    }\n\n    var hasBracket = tokens[0] === '('\n    if (hasBracket) tokens.shift()\n\n    var key = tokens.shift()\n    if (hasBracket) {\n      if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])\n      tokens.shift()\n    }\n\n    var value = null\n\n    switch (tokens[0]) {\n      case ':':\n        if (map[key] !== undefined) throw new Error('Duplicate option map key ' + key)\n\n        tokens.shift()\n\n        value = parse(tokens.shift())\n\n        if (value === '{') {\n          // option foo = {bar: baz}\n          value = onoptionMap(tokens)\n        }\n\n        map[key] = value\n\n        if (tokens[0] === ';') {\n          tokens.shift()\n        }\n        break\n\n      case '{':\n        tokens.shift()\n        value = onoptionMap(tokens)\n\n        if (map[key] === undefined) map[key] = []\n        if (!Array.isArray(map[key])) throw new Error('Duplicate option map key ' + key)\n\n        map[key].push(value)\n        break\n\n      default:\n        throw new Error('Unexpected token in option map: ' + tokens[0])\n    }\n  }\n\n  throw new Error('No closing tag for option map')\n}\n\nvar onimport = function (tokens) {\n  tokens.shift()\n  var file = tokens.shift().replace(/^\"+|\"+$/gm, '')\n\n  if (tokens[0] !== ';') throw new Error('Unexpected token: ' + tokens[0] + '. Expected \";\"')\n\n  tokens.shift()\n  return file\n}\n\nvar onservice = function (tokens) {\n  tokens.shift()\n\n  var service = {\n    name: tokens.shift(),\n    methods: [],\n    options: {}\n  }\n\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])\n  tokens.shift()\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift()\n      // there goes optional semicolon after the enclosing \"}\"\n      if (tokens[0] === ';') tokens.shift()\n      return service\n    }\n\n    switch (tokens[0]) {\n      case 'option':\n        var opt = onoption(tokens)\n        if (service.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name)\n        service.options[opt.name] = opt.value\n        break\n      case 'rpc':\n        service.methods.push(onrpc(tokens))\n        break\n      default:\n        throw new Error('Unexpected token in service: ' + tokens[0])\n    }\n  }\n\n  throw new Error('No closing tag for service')\n}\n\nvar onrpc = function (tokens) {\n  tokens.shift()\n\n  var rpc = {\n    name: tokens.shift(),\n    input_type: null,\n    output_type: null,\n    client_streaming: false,\n    server_streaming: false,\n    options: {}\n  }\n\n  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0])\n  tokens.shift()\n\n  if (tokens[0] === 'stream') {\n    tokens.shift()\n    rpc.client_streaming = true\n  }\n\n  rpc.input_type = tokens.shift()\n\n  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])\n  tokens.shift()\n\n  if (tokens[0] !== 'returns') throw new Error('Expected returns but found ' + tokens[0])\n  tokens.shift()\n\n  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0])\n  tokens.shift()\n\n  if (tokens[0] === 'stream') {\n    tokens.shift()\n    rpc.server_streaming = true\n  }\n\n  rpc.output_type = tokens.shift()\n\n  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])\n  tokens.shift()\n\n  if (tokens[0] === ';') {\n    tokens.shift()\n    return rpc\n  }\n\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])\n  tokens.shift()\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift()\n      // there goes optional semicolon after the enclosing \"}\"\n      if (tokens[0] === ';') tokens.shift()\n      return rpc\n    }\n\n    if (tokens[0] === 'option') {\n      var opt = onoption(tokens)\n      if (rpc.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name)\n      rpc.options[opt.name] = opt.value\n    } else {\n      throw new Error('Unexpected token in rpc options: ' + tokens[0])\n    }\n  }\n\n  throw new Error('No closing tag for rpc')\n}\n\nvar parse = function (buf) {\n  var tokens = tokenize(buf.toString())\n  // check for isolated strings in tokens by looking for opening quote\n  for (var i = 0; i < tokens.length; i++) {\n    if (/^(\"|')([^'\"]*)$/.test(tokens[i])) {\n      var j\n      if (tokens[i].length === 1) {\n        j = i + 1\n      } else {\n        j = i\n      }\n      // look ahead for the closing quote and collapse all\n      // in-between tokens into a single token\n      for (j; j < tokens.length; j++) {\n        if (/^[^'\"\\\\]*(?:\\\\.[^'\"\\\\]*)*(\"|')$/.test(tokens[j])) {\n          tokens = tokens.slice(0, i).concat(tokens.slice(i, j + 1).join('')).concat(tokens.slice(j + 1))\n          break\n        }\n      }\n    }\n  }\n  var schema = {\n    syntax: 3,\n    package: null,\n    imports: [],\n    enums: [],\n    messages: [],\n    options: {},\n    extends: []\n  }\n\n  var firstline = true\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case 'package':\n        schema.package = onpackagename(tokens)\n        break\n\n      case 'syntax':\n        if (!firstline) throw new Error('Protobuf syntax version should be first thing in file')\n        schema.syntax = onsyntaxversion(tokens)\n        break\n\n      case 'message':\n        schema.messages.push(onmessage(tokens))\n        break\n\n      case 'enum':\n        schema.enums.push(onenum(tokens))\n        break\n\n      case 'option':\n        var opt = onoption(tokens)\n        if (schema.options[opt.name]) throw new Error('Duplicate option ' + opt.name)\n        schema.options[opt.name] = opt.value\n        break\n\n      case 'import':\n        schema.imports.push(onimport(tokens))\n        break\n\n      case 'extend':\n        schema.extends.push(onextend(tokens))\n        break\n\n      case 'service':\n        if (!schema.services) schema.services = []\n        schema.services.push(onservice(tokens))\n        break\n\n      default:\n        throw new Error('Unexpected token: ' + tokens[0])\n    }\n    firstline = false\n  }\n\n  // now iterate over messages and propagate extends\n  schema.extends.forEach(function (ext) {\n    schema.messages.forEach(function (msg) {\n      if (msg.name === ext.name) {\n        ext.message.fields.forEach(function (field) {\n          if (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to) {\n            throw new Error(msg.name + ' does not declare ' + field.tag + ' as an extension number')\n          }\n          msg.fields.push(field)\n        })\n      }\n    })\n  })\n\n  schema.messages.forEach(function (msg) {\n    msg.fields.forEach(function (field) {\n      var fieldSplit\n      var messageName\n      var nestedEnumName\n      var message\n\n      function enumNameIsFieldType (en) {\n        return en.name === field.type\n      }\n\n      function enumNameIsNestedEnumName (en) {\n        return en.name === nestedEnumName\n      }\n\n      if (field.options && field.options.packed === 'true') {\n        if (PACKABLE_TYPES.indexOf(field.type) === -1) {\n          // let's see if it's an enum\n          if (field.type.indexOf('.') === -1) {\n            if (msg.enums && msg.enums.some(enumNameIsFieldType)) {\n              return\n            }\n          } else {\n            fieldSplit = field.type.split('.')\n            if (fieldSplit.length > 2) {\n              throw new Error('what is this?')\n            }\n\n            messageName = fieldSplit[0]\n            nestedEnumName = fieldSplit[1]\n\n            schema.messages.some(function (msg) {\n              if (msg.name === messageName) {\n                message = msg\n                return msg\n              }\n            })\n\n            if (message && message.enums && message.enums.some(enumNameIsNestedEnumName)) {\n              return\n            }\n          }\n\n          throw new Error(\n            'Fields of type ' + field.type + ' cannot be declared [packed=true]. ' +\n            'Only repeated fields of primitive numeric types (types which use ' +\n            'the varint, 32-bit, or 64-bit wire types) can be declared \"packed\". ' +\n            'See https://developers.google.com/protocol-buffers/docs/encoding#optional'\n          )\n        }\n      }\n    })\n  })\n\n  return schema\n}\n\nmodule.exports = parse\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
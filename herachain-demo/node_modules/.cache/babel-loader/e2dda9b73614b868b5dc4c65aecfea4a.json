{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable class-methods-use-this */\nconst _ = require('lodash');\n\nconst utils = require('../../../caver-utils');\n\nconst PrivateKey = require('./privateKey');\n\nconst {\n  KEY_ROLE,\n  MAXIMUM_KEY_NUM,\n  isMultipleKeysFormat,\n  isRoleBasedKeysFormat\n} = require('./keyringHelper');\n\nconst Account = require('../../../caver-account');\n\nconst {\n  fillWeightedMultiSigOptionsForRoleBased\n} = require('../../../caver-account/src/accountKey/accountKeyHelper');\n\nconst {\n  validateForSigning,\n  validateIndexWithKeys,\n  encryptKey,\n  formatEncrypted\n} = require('./keyringHelper');\n/**\n * `RoleBasedKeyring` is a class that stores the address of the account and the private keys to be used for each role in the form of an array.\n *\n * `RoleBasedKeyring` defines keys which is implemented as a two-dimensional array (empty keys looks like `[ [], [], [] ]`) that can include multiple keys for each role.\n * The first array element defines the private key(s) for `roleTransactionKey`, the second defines private key(s) for `roleAccountUpdateKey`, and the third defines the private key(s) for `roleFeePayerKey`.\n *\n * @class\n * @hideconstructor\n */\n\n\nclass RoleBasedKeyring {\n  /**\n   * creates a RoleBasedKeyring.\n   * @param {string} address - The address of keyring.\n   * @param {Array.<Array<string>>|Array.<Array<PrivateKey>>} keys - The keys to use in RoleBasedKeyring.\n   */\n  constructor(address, keys) {\n    this.address = address;\n    this.keys = keys;\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get type() {\n    return 'RoleBasedKeyring';\n  }\n\n  set type(t) {\n    throw new Error(`keyring type cannot be set.`);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get address() {\n    return this._address;\n  }\n\n  set address(addressInput) {\n    if (!utils.isAddress(addressInput)) throw new Error(`Invalid address : ${addressInput}`);\n    this._address = utils.addHexPrefix(addressInput).toLowerCase();\n  }\n  /**\n   * @type {Array.<Array.<PrivateKey>>}\n   */\n\n\n  get keys() {\n    return this._keys;\n  }\n\n  set keys(keyInput) {\n    if (keyInput === null) {\n      this._key = null;\n      return;\n    }\n\n    this._keys = formattingForKeyInKeyring(keyInput);\n  }\n  /**\n   * @type {Array.<PrivateKey>}\n   */\n\n\n  get roleTransactionKey() {\n    return this.getKeyByRole(KEY_ROLE.roleTransactionKey);\n  }\n  /**\n   * @type {Array.<PrivateKey>}\n   */\n\n\n  get roleAccountUpdateKey() {\n    return this.getKeyByRole(KEY_ROLE.roleAccountUpdateKey);\n  }\n  /**\n   * @type {Array.<PrivateKey>}\n   */\n\n\n  get roleFeePayerKey() {\n    return this.getKeyByRole(KEY_ROLE.roleFeePayerKey);\n  }\n  /**\n   * Returns public key strings for each roles.\n   *\n   * @example\n   * const publicKeys = keyring.getPublicKey()\n   *\n   * @param {boolean} [compressed] Whether in compressed format or not.\n   * @return {Array.<Array<string>>} The public keys of the keyring.\n   */\n\n\n  getPublicKey() {\n    let compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const publicKeys = generateKeysFormat();\n\n    for (let i = 0; i < KEY_ROLE.roleLast; i++) {\n      for (const k of this._keys[i]) {\n        publicKeys[i].push(k.getPublicKey(compressed));\n      }\n    }\n\n    return publicKeys;\n  }\n  /**\n   * Returns a copied RoleBasedKeyring instance.\n   *\n   * @example\n   * const copied = keyring.copy()\n   *\n   * @return {RoleBasedKeyring} A copied RoleBasedKeyring instance.\n   */\n\n\n  copy() {\n    return new RoleBasedKeyring(this.address, this.keys);\n  }\n  /**\n   * Signs with transactionHash with the private keys and returns signatures.\n   *\n   * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\n   * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\n   *\n   * If the user has not defined an `index` parameter, `keyring.sign` signs transaction using all the private keys used by the role.\n   * If `index` is defined, the `keyring.sign` signs transaction using only one private key at the index.\n   * The role used in caver-js can be checked through {@link KeyringFactory.role|caver.wallet.keyring.role}.\n   *\n   * @param {string} transactionHash The hash of transaction.\n   * @param {string|number} chainId The chainId specific to the network.\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n   * @return {SignatureData|Array.<SignatureData>} A {@link SignatureData} when `index` is deinfed, otherwise an array of {@link SignatureData}.\n   */\n\n\n  sign(transactionHash, chainId, role, index) {\n    validateForSigning(transactionHash, chainId);\n    const keys = this.getKeyByRole(role);\n\n    if (index !== undefined) {\n      validateIndexWithKeys(index, keys.length);\n      return keys[index].sign(transactionHash, chainId);\n    }\n\n    const signatures = [];\n\n    for (const k of keys) {\n      signatures.push(k.sign(transactionHash, chainId));\n    }\n\n    return signatures;\n  }\n  /**\n   * Signs with transactionHash with the private keys and returns signatures which V is 0 or 1 (parity of the y-value of a secp256k1 signature).\n   *\n   * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\n   * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\n   *\n   * If the user has not defined an `index` parameter, `keyring.sign` signs transaction using all the private keys used by the role.\n   * If `index` is defined, the `keyring.sign` signs transaction using only one private key at the index.\n   * The role used in caver-js can be checked through {@link KeyringFactory.role|caver.wallet.keyring.role}.\n   *\n   * @example\n   * const signed = keyring.ecsign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', caver.wallet.keyring.role.roleTransactionKey)\n   * const signed = keyring.ecsign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', caver.wallet.keyring.role.roleAccountUpdateKey, 1)\n   *\n   * @param {string} hash The hashed data to sign.\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n   * @return {SignatureData|Array.<SignatureData>} A {@link SignatureData} when `index` is deinfed, otherwise an array of {@link SignatureData}.\n   */\n\n\n  ecsign(hash, role, index) {\n    if (!utils.isValidHashStrict(hash)) throw new Error(`Invalid hash: ${hash}`);\n    const keys = this.getKeyByRole(role);\n\n    if (index !== undefined) {\n      validateIndexWithKeys(index, keys.length);\n      return keys[index].ecsign(hash);\n    }\n\n    const signatures = [];\n\n    for (const k of keys) {\n      signatures.push(k.ecsign(hash));\n    }\n\n    return signatures;\n  }\n  /**\n   * Signs message with Klaytn-specific prefix.\n   *\n   * This calculates a Klaytn-specific signature with:\n   * `sign(keccak256(\"\\x19Klaytn Signed Message:\\n\" + len(message) + message)))`.\n   *\n   * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\n   * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\n   *\n   * If the user has not provided the `index` parameter, `caver.wallet.signMessage` signs message using all the private keys used by the role.\n   * If the `index` parameter is given, `caver.wallet.signMessage` signs message using only one private key at the given index.\n   * The role used in caver-js can be found from {@link KeyringFactory.role|caver.wallet.keyring.role}.\n   *\n   * @example\n   * const signed = keyring.signMessage('message to sign', caver.wallet.keyring.role.roleTransactionKey)\n   *\n   * @param {string} message The message string to sign.\n   * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\n   * @param {number} [index] The index of the key to be used.\n   * @return {KeyringContainer.SignedMessage} An object that includes the result of signing.\n   */\n\n\n  signMessage(message, role, index) {\n    if (role === undefined) throw new Error(`role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.`);\n    const messageHash = utils.hashMessage(message);\n    const keys = this.getKeyByRole(role);\n    const signatures = [];\n\n    if (index !== undefined) {\n      validateIndexWithKeys(index, keys.length);\n      signatures.push(keys[index].signMessage(messageHash));\n    } else {\n      for (const k of keys) {\n        signatures.push(k.signMessage(messageHash));\n      }\n    }\n\n    return {\n      messageHash,\n      signatures,\n      message\n    };\n  }\n  /**\n   * Returns the private key(s) used by the role entered as a parameter.\n   *\n   * @example\n   * const key = keyring.getKeyByRole(caver.wallet.keyring.role.roleTransactionKey)\n   *\n   * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\n   * @return {Array.<PrivateKey>} An instance of PrivateKey.\n   */\n\n\n  getKeyByRole(role) {\n    if (role === undefined) throw new Error(`role should be defined.`);\n    if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(`Invalid role number: ${role}`);\n    let key = this._keys[role];\n\n    if (key.length === 0 && role > KEY_ROLE.roleTransactionKey) {\n      if (this._keys[KEY_ROLE.roleTransactionKey].length === 0) {\n        throw new Error(`The key with ${KEY_ROLE[role]} role does not exist. The ${KEY_ROLE[0]} for the default role is also empty.`);\n      }\n\n      key = this._keys[KEY_ROLE.roleTransactionKey];\n    }\n\n    return key;\n  }\n  /**\n   * Returns the {@link Account} instance for updating the {@link Account.AccountKey|AccountKey} of the Klaytn accounts.\n   * The {@link Account} instance has an {@link Account.AccountKey|AccountKey} instance that can contain public key(s) inside, which will be sent to Klaytn Network and used for validating transactions.\n   * Please note that if you update the AccountKey of the Account stored in the Klaytn, the old private key(s) cannot be used anymore.\n   *\n   * `RoleBasedKeyring` returns an {@link Account} instance that includes the address in the keyring and an instance of {@link AccountKeyRoleBased}.\n   *\n   * @example\n   * const account = keyring.toAccount()\n   *\n   * @param {Array.<WeightedMultiSigOptions>} [options] An array of the `WeightedMultiSigOptions` instances containing information that should be defined when updating your existing account to the one with a number of private keys. The `RoleBasedKeyring` uses different private keys for each role, a `WeightedMultiSigOptions` instance must be defined for each role in an array. If multiple keys are used and `options` are not defined for specific role, defualt WeightedMultiSigOptions (`{ threshold: 1, weights: [1, 1...}}`) is used.\n   * @return {Account} An Account instance to be used when a user updates AccountKey for their account in the Klaytn. Note that if you want to replace the existing keyring (or the existing private key) with a new keyring (or a new private key) for your account, you must update your AccountKey by sending an Account Update transaction to Klaytn beforehand.\n   */\n\n\n  toAccount(options) {\n    if (options !== undefined && !_.isArray(options)) throw new Error(`options for an account should define threshold and weight for each roles in an array format`);\n    const lengths = [];\n\n    for (const k of this.keys) lengths.push(k.length);\n\n    options = fillWeightedMultiSigOptionsForRoleBased(lengths, options);\n    const publicKeysByRole = this.getPublicKey();\n    return Account.createWithAccountKeyRoleBased(this.address, publicKeysByRole, options);\n  }\n  /**\n   * Encrypts a keyring and returns a keystore v4 standard.\n   * For more information, please refer to {@link https://kips.klaytn.com/KIPs/kip-3|KIP-3}.\n   *\n   * `options` can include below:\n   * {\n   *   salt: ...,\n   *   iv: ...,\n   *   kdf: ...,\n   *   dklen: ...,\n   *   c: ...,\n   *   n: ...,\n   *   r: ...,\n   *   p: ...,\n   *   cipher: ...,\n   *   uuid: ...,\n   *   cipher: ...,\n   * }\n   *\n   * @example\n   * const encrypted = keyring.encrypt('password')\n   *\n   * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n   * @param {object} [options] The options parameter allows you to specify the values to use when using encrypt.\n   * @return {KeyringFactory.Keystore} The encrypted keystore v4.\n   */\n\n\n  encrypt(password) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const keyring = [];\n\n    for (let i = KEY_ROLE.roleTransactionKey; i < KEY_ROLE.roleLast; i++) {\n      const roledKey = this._keys[i];\n      keyring.push(encryptKey(roledKey, password, options));\n    }\n\n    return formatEncrypted(4, this._address, keyring, options);\n  }\n  /**\n   * Returns the {@link https://docs.klaytn.com/klaytn/design/accounts#klaytn-wallet-key-format|KlaytnWalletKey} string for the keyring.\n   * This function will throw error because `MultipleKeyring` uses more than one private key.\n   *\n   * @example\n   * const klaytnWalletKey = keyring.getKlaytnWalletKey()\n   *\n   * @ignore\n   * @return {string}\n   */\n\n\n  getKlaytnWalletKey() {\n    throw new Error(`Not supported for this class.`);\n  }\n  /**\n   * Encrypts a keyring and returns a keystore v3 object.\n   *\n   * Note that {@link MultipleKeyring} and {@link RoleBasedKeyring} cannot use encryptV3.\n   * In this case, please use {@link MultipleKeyring#encrypt|keyring.encrypt} with a keystore V4 standard.\n   *\n   * @example\n   * const encrypted = keyring.encryptV3('password')\n   *\n   * @ignore\n   * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n   * @param {object} [options] The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n   * @return {object}\n   */\n\n\n  encryptV3(password, options) {\n    throw new Error(`Not supported for this class. Use 'keyring.encrypt(password)'.`);\n  }\n  /**\n   * Returns `true` if keyring has decoupled key.\n   *\n   * @example\n   * const isDecupled = keyring.isDecoupled()\n   *\n   * @return {boolean} `true` if keyring has decoupled key.\n   */\n\n\n  isDecoupled() {\n    return true;\n  }\n\n}\n\nmodule.exports = RoleBasedKeyring;\n/**\n * Format the key parameters passed by the user to create a keyring instance into a two-dimensional array containing PrivateKey instances.\n *\n * The cases of the parameter that the user passes to the function is as follows, and this function formats it as a two-dimensional array.\n * PrivateKey instance: PrivateKey{}\n * single private key string: `0x{private key}`\n * multiple private key strings: [`0x{private key}`, `0x{private key}`]\n * multiple PrivateKey instances: [PrivateKey{}, PrivateKey{}]\n * role-based private key strings: [[`0x{private key}`], [`0x{private key}`, `0x{private key}`], [`0x{private key}`]]\n * role-based PrivateKey instances: [[PrivateKey{}], [PrivateKey{}, PrivateKey{}], [PrivateKey{}]]\n *\n * @param {string|PrivateKey|Array.<string|PrivateKey>|Array.<Array.<string|PrivateKey>>} keyInput The input parameter for key variable in Keyring.\n * @return {Array.<Array.<PrivateKey>>}\n */\n\nfunction formattingForKeyInKeyring(keyInput) {\n  if (keyInput === null) {\n    return keyInput;\n  }\n\n  if (keyInput instanceof PrivateKey || _.isString(keyInput)) {\n    keyInput = [[keyInput], [], []];\n  } else if (isMultipleKeysFormat(keyInput)) {\n    // [`0x{private key}`, `0x{private key}`, `0x{private key}`]\n    keyInput = [keyInput, [], []];\n  } else if (!isRoleBasedKeysFormat(keyInput)) {\n    throw new Error(`Invalid format for key variable in keyring`);\n  }\n\n  const keys = generateKeysFormat();\n\n  for (let i = 0; i < KEY_ROLE.roleLast; i++) {\n    fillRoleKey(keys, i, keyInput[i]);\n  }\n\n  return keys;\n}\n\nfunction generateKeysFormat() {\n  return Array(KEY_ROLE.roleLast).fill(null).map(() => []);\n}\n\nfunction fillRoleKey(keys, role, keyToAdd) {\n  if (keyToAdd === undefined) return;\n  keyToAdd = Array.isArray(keyToAdd) ? keyToAdd : [keyToAdd];\n  if (keyToAdd.length > MAXIMUM_KEY_NUM) throw new Error(`The maximum number of private keys that can be used in keyring is ${MAXIMUM_KEY_NUM}.`);\n  if (role >= KEY_ROLE.roleLast) throw new Error(`Unsupported role number. The role number should be less than ${KEY_ROLE.roleLast}. Please use 'caver.wallet.keyring.role'`);\n\n  for (const keyString of keyToAdd) {\n    const key = keyString instanceof PrivateKey ? keyString : new PrivateKey(keyString);\n    keys[role].push(key);\n  }\n}","map":{"version":3,"names":["_","require","utils","PrivateKey","KEY_ROLE","MAXIMUM_KEY_NUM","isMultipleKeysFormat","isRoleBasedKeysFormat","Account","fillWeightedMultiSigOptionsForRoleBased","validateForSigning","validateIndexWithKeys","encryptKey","formatEncrypted","RoleBasedKeyring","constructor","address","keys","type","t","Error","_address","addressInput","isAddress","addHexPrefix","toLowerCase","_keys","keyInput","_key","formattingForKeyInKeyring","roleTransactionKey","getKeyByRole","roleAccountUpdateKey","roleFeePayerKey","getPublicKey","compressed","publicKeys","generateKeysFormat","i","roleLast","k","push","copy","sign","transactionHash","chainId","role","index","undefined","length","signatures","ecsign","hash","isValidHashStrict","signMessage","message","messageHash","hashMessage","key","toAccount","options","isArray","lengths","publicKeysByRole","createWithAccountKeyRoleBased","encrypt","password","keyring","roledKey","getKlaytnWalletKey","encryptV3","isDecoupled","module","exports","isString","fillRoleKey","Array","fill","map","keyToAdd","keyString"],"sources":["/Users/austinhatch/Documents/GitHub/Heracoin/herachain-demo/node_modules/caver-js/packages/caver-wallet/src/keyring/roleBasedKeyring.js"],"sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* eslint-disable no-unused-vars */\n/* eslint-disable class-methods-use-this */\n\nconst _ = require('lodash')\n\nconst utils = require('../../../caver-utils')\nconst PrivateKey = require('./privateKey')\nconst { KEY_ROLE, MAXIMUM_KEY_NUM, isMultipleKeysFormat, isRoleBasedKeysFormat } = require('./keyringHelper')\nconst Account = require('../../../caver-account')\nconst { fillWeightedMultiSigOptionsForRoleBased } = require('../../../caver-account/src/accountKey/accountKeyHelper')\nconst { validateForSigning, validateIndexWithKeys, encryptKey, formatEncrypted } = require('./keyringHelper')\n\n/**\n * `RoleBasedKeyring` is a class that stores the address of the account and the private keys to be used for each role in the form of an array.\n *\n * `RoleBasedKeyring` defines keys which is implemented as a two-dimensional array (empty keys looks like `[ [], [], [] ]`) that can include multiple keys for each role.\n * The first array element defines the private key(s) for `roleTransactionKey`, the second defines private key(s) for `roleAccountUpdateKey`, and the third defines the private key(s) for `roleFeePayerKey`.\n *\n * @class\n * @hideconstructor\n */\nclass RoleBasedKeyring {\n    /**\n     * creates a RoleBasedKeyring.\n     * @param {string} address - The address of keyring.\n     * @param {Array.<Array<string>>|Array.<Array<PrivateKey>>} keys - The keys to use in RoleBasedKeyring.\n     */\n    constructor(address, keys) {\n        this.address = address\n        this.keys = keys\n    }\n\n    /**\n     * @type {string}\n     */\n    get type() {\n        return 'RoleBasedKeyring'\n    }\n\n    set type(t) {\n        throw new Error(`keyring type cannot be set.`)\n    }\n\n    /**\n     * @type {string}\n     */\n    get address() {\n        return this._address\n    }\n\n    set address(addressInput) {\n        if (!utils.isAddress(addressInput)) throw new Error(`Invalid address : ${addressInput}`)\n\n        this._address = utils.addHexPrefix(addressInput).toLowerCase()\n    }\n\n    /**\n     * @type {Array.<Array.<PrivateKey>>}\n     */\n    get keys() {\n        return this._keys\n    }\n\n    set keys(keyInput) {\n        if (keyInput === null) {\n            this._key = null\n            return\n        }\n\n        this._keys = formattingForKeyInKeyring(keyInput)\n    }\n\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n    get roleTransactionKey() {\n        return this.getKeyByRole(KEY_ROLE.roleTransactionKey)\n    }\n\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n    get roleAccountUpdateKey() {\n        return this.getKeyByRole(KEY_ROLE.roleAccountUpdateKey)\n    }\n\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n    get roleFeePayerKey() {\n        return this.getKeyByRole(KEY_ROLE.roleFeePayerKey)\n    }\n\n    /**\n     * Returns public key strings for each roles.\n     *\n     * @example\n     * const publicKeys = keyring.getPublicKey()\n     *\n     * @param {boolean} [compressed] Whether in compressed format or not.\n     * @return {Array.<Array<string>>} The public keys of the keyring.\n     */\n    getPublicKey(compressed = false) {\n        const publicKeys = generateKeysFormat()\n        for (let i = 0; i < KEY_ROLE.roleLast; i++) {\n            for (const k of this._keys[i]) {\n                publicKeys[i].push(k.getPublicKey(compressed))\n            }\n        }\n        return publicKeys\n    }\n\n    /**\n     * Returns a copied RoleBasedKeyring instance.\n     *\n     * @example\n     * const copied = keyring.copy()\n     *\n     * @return {RoleBasedKeyring} A copied RoleBasedKeyring instance.\n     */\n    copy() {\n        return new RoleBasedKeyring(this.address, this.keys)\n    }\n\n    /**\n     * Signs with transactionHash with the private keys and returns signatures.\n     *\n     * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\n     * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\n     *\n     * If the user has not defined an `index` parameter, `keyring.sign` signs transaction using all the private keys used by the role.\n     * If `index` is defined, the `keyring.sign` signs transaction using only one private key at the index.\n     * The role used in caver-js can be checked through {@link KeyringFactory.role|caver.wallet.keyring.role}.\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId specific to the network.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n     * @return {SignatureData|Array.<SignatureData>} A {@link SignatureData} when `index` is deinfed, otherwise an array of {@link SignatureData}.\n     */\n    sign(transactionHash, chainId, role, index) {\n        validateForSigning(transactionHash, chainId)\n\n        const keys = this.getKeyByRole(role)\n\n        if (index !== undefined) {\n            validateIndexWithKeys(index, keys.length)\n            return keys[index].sign(transactionHash, chainId)\n        }\n\n        const signatures = []\n        for (const k of keys) {\n            signatures.push(k.sign(transactionHash, chainId))\n        }\n        return signatures\n    }\n\n    /**\n     * Signs with transactionHash with the private keys and returns signatures which V is 0 or 1 (parity of the y-value of a secp256k1 signature).\n     *\n     * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\n     * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\n     *\n     * If the user has not defined an `index` parameter, `keyring.sign` signs transaction using all the private keys used by the role.\n     * If `index` is defined, the `keyring.sign` signs transaction using only one private key at the index.\n     * The role used in caver-js can be checked through {@link KeyringFactory.role|caver.wallet.keyring.role}.\n     *\n     * @example\n     * const signed = keyring.ecsign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', caver.wallet.keyring.role.roleTransactionKey)\n     * const signed = keyring.ecsign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', caver.wallet.keyring.role.roleAccountUpdateKey, 1)\n     *\n     * @param {string} hash The hashed data to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n     * @return {SignatureData|Array.<SignatureData>} A {@link SignatureData} when `index` is deinfed, otherwise an array of {@link SignatureData}.\n     */\n    ecsign(hash, role, index) {\n        if (!utils.isValidHashStrict(hash)) throw new Error(`Invalid hash: ${hash}`)\n\n        const keys = this.getKeyByRole(role)\n\n        if (index !== undefined) {\n            validateIndexWithKeys(index, keys.length)\n            return keys[index].ecsign(hash)\n        }\n\n        const signatures = []\n        for (const k of keys) {\n            signatures.push(k.ecsign(hash))\n        }\n        return signatures\n    }\n\n    /**\n     * Signs message with Klaytn-specific prefix.\n     *\n     * This calculates a Klaytn-specific signature with:\n     * `sign(keccak256(\"\\x19Klaytn Signed Message:\\n\" + len(message) + message)))`.\n     *\n     * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\n     * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\n     *\n     * If the user has not provided the `index` parameter, `caver.wallet.signMessage` signs message using all the private keys used by the role.\n     * If the `index` parameter is given, `caver.wallet.signMessage` signs message using only one private key at the given index.\n     * The role used in caver-js can be found from {@link KeyringFactory.role|caver.wallet.keyring.role}.\n     *\n     * @example\n     * const signed = keyring.signMessage('message to sign', caver.wallet.keyring.role.roleTransactionKey)\n     *\n     * @param {string} message The message string to sign.\n     * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\n     * @param {number} [index] The index of the key to be used.\n     * @return {KeyringContainer.SignedMessage} An object that includes the result of signing.\n     */\n    signMessage(message, role, index) {\n        if (role === undefined) throw new Error(`role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.`)\n        const messageHash = utils.hashMessage(message)\n\n        const keys = this.getKeyByRole(role)\n\n        const signatures = []\n        if (index !== undefined) {\n            validateIndexWithKeys(index, keys.length)\n            signatures.push(keys[index].signMessage(messageHash))\n        } else {\n            for (const k of keys) {\n                signatures.push(k.signMessage(messageHash))\n            }\n        }\n        return {\n            messageHash,\n            signatures,\n            message,\n        }\n    }\n\n    /**\n     * Returns the private key(s) used by the role entered as a parameter.\n     *\n     * @example\n     * const key = keyring.getKeyByRole(caver.wallet.keyring.role.roleTransactionKey)\n     *\n     * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\n     * @return {Array.<PrivateKey>} An instance of PrivateKey.\n     */\n    getKeyByRole(role) {\n        if (role === undefined) throw new Error(`role should be defined.`)\n        if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(`Invalid role number: ${role}`)\n        let key = this._keys[role]\n        if (key.length === 0 && role > KEY_ROLE.roleTransactionKey) {\n            if (this._keys[KEY_ROLE.roleTransactionKey].length === 0) {\n                throw new Error(\n                    `The key with ${KEY_ROLE[role]} role does not exist. The ${KEY_ROLE[0]} for the default role is also empty.`\n                )\n            }\n\n            key = this._keys[KEY_ROLE.roleTransactionKey]\n        }\n        return key\n    }\n\n    /**\n     * Returns the {@link Account} instance for updating the {@link Account.AccountKey|AccountKey} of the Klaytn accounts.\n     * The {@link Account} instance has an {@link Account.AccountKey|AccountKey} instance that can contain public key(s) inside, which will be sent to Klaytn Network and used for validating transactions.\n     * Please note that if you update the AccountKey of the Account stored in the Klaytn, the old private key(s) cannot be used anymore.\n     *\n     * `RoleBasedKeyring` returns an {@link Account} instance that includes the address in the keyring and an instance of {@link AccountKeyRoleBased}.\n     *\n     * @example\n     * const account = keyring.toAccount()\n     *\n     * @param {Array.<WeightedMultiSigOptions>} [options] An array of the `WeightedMultiSigOptions` instances containing information that should be defined when updating your existing account to the one with a number of private keys. The `RoleBasedKeyring` uses different private keys for each role, a `WeightedMultiSigOptions` instance must be defined for each role in an array. If multiple keys are used and `options` are not defined for specific role, defualt WeightedMultiSigOptions (`{ threshold: 1, weights: [1, 1...}}`) is used.\n     * @return {Account} An Account instance to be used when a user updates AccountKey for their account in the Klaytn. Note that if you want to replace the existing keyring (or the existing private key) with a new keyring (or a new private key) for your account, you must update your AccountKey by sending an Account Update transaction to Klaytn beforehand.\n     */\n    toAccount(options) {\n        if (options !== undefined && !_.isArray(options))\n            throw new Error(`options for an account should define threshold and weight for each roles in an array format`)\n\n        const lengths = []\n        for (const k of this.keys) lengths.push(k.length)\n        options = fillWeightedMultiSigOptionsForRoleBased(lengths, options)\n\n        const publicKeysByRole = this.getPublicKey()\n        return Account.createWithAccountKeyRoleBased(this.address, publicKeysByRole, options)\n    }\n\n    /**\n     * Encrypts a keyring and returns a keystore v4 standard.\n     * For more information, please refer to {@link https://kips.klaytn.com/KIPs/kip-3|KIP-3}.\n     *\n     * `options` can include below:\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     *\n     * @example\n     * const encrypted = keyring.encrypt('password')\n     *\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} [options] The options parameter allows you to specify the values to use when using encrypt.\n     * @return {KeyringFactory.Keystore} The encrypted keystore v4.\n     */\n    encrypt(password, options = {}) {\n        const keyring = []\n\n        for (let i = KEY_ROLE.roleTransactionKey; i < KEY_ROLE.roleLast; i++) {\n            const roledKey = this._keys[i]\n            keyring.push(encryptKey(roledKey, password, options))\n        }\n\n        return formatEncrypted(4, this._address, keyring, options)\n    }\n\n    /**\n     * Returns the {@link https://docs.klaytn.com/klaytn/design/accounts#klaytn-wallet-key-format|KlaytnWalletKey} string for the keyring.\n     * This function will throw error because `MultipleKeyring` uses more than one private key.\n     *\n     * @example\n     * const klaytnWalletKey = keyring.getKlaytnWalletKey()\n     *\n     * @ignore\n     * @return {string}\n     */\n    getKlaytnWalletKey() {\n        throw new Error(`Not supported for this class.`)\n    }\n\n    /**\n     * Encrypts a keyring and returns a keystore v3 object.\n     *\n     * Note that {@link MultipleKeyring} and {@link RoleBasedKeyring} cannot use encryptV3.\n     * In this case, please use {@link MultipleKeyring#encrypt|keyring.encrypt} with a keystore V4 standard.\n     *\n     * @example\n     * const encrypted = keyring.encryptV3('password')\n     *\n     * @ignore\n     * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} [options] The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n     * @return {object}\n     */\n    encryptV3(password, options) {\n        throw new Error(`Not supported for this class. Use 'keyring.encrypt(password)'.`)\n    }\n\n    /**\n     * Returns `true` if keyring has decoupled key.\n     *\n     * @example\n     * const isDecupled = keyring.isDecoupled()\n     *\n     * @return {boolean} `true` if keyring has decoupled key.\n     */\n    isDecoupled() {\n        return true\n    }\n}\n\nmodule.exports = RoleBasedKeyring\n\n/**\n * Format the key parameters passed by the user to create a keyring instance into a two-dimensional array containing PrivateKey instances.\n *\n * The cases of the parameter that the user passes to the function is as follows, and this function formats it as a two-dimensional array.\n * PrivateKey instance: PrivateKey{}\n * single private key string: `0x{private key}`\n * multiple private key strings: [`0x{private key}`, `0x{private key}`]\n * multiple PrivateKey instances: [PrivateKey{}, PrivateKey{}]\n * role-based private key strings: [[`0x{private key}`], [`0x{private key}`, `0x{private key}`], [`0x{private key}`]]\n * role-based PrivateKey instances: [[PrivateKey{}], [PrivateKey{}, PrivateKey{}], [PrivateKey{}]]\n *\n * @param {string|PrivateKey|Array.<string|PrivateKey>|Array.<Array.<string|PrivateKey>>} keyInput The input parameter for key variable in Keyring.\n * @return {Array.<Array.<PrivateKey>>}\n */\nfunction formattingForKeyInKeyring(keyInput) {\n    if (keyInput === null) {\n        return keyInput\n    }\n\n    if (keyInput instanceof PrivateKey || _.isString(keyInput)) {\n        keyInput = [[keyInput], [], []]\n    } else if (isMultipleKeysFormat(keyInput)) {\n        // [`0x{private key}`, `0x{private key}`, `0x{private key}`]\n        keyInput = [keyInput, [], []]\n    } else if (!isRoleBasedKeysFormat(keyInput)) {\n        throw new Error(`Invalid format for key variable in keyring`)\n    }\n\n    const keys = generateKeysFormat()\n    for (let i = 0; i < KEY_ROLE.roleLast; i++) {\n        fillRoleKey(keys, i, keyInput[i])\n    }\n\n    return keys\n}\n\nfunction generateKeysFormat() {\n    return Array(KEY_ROLE.roleLast)\n        .fill(null)\n        .map(() => [])\n}\n\nfunction fillRoleKey(keys, role, keyToAdd) {\n    if (keyToAdd === undefined) return\n    keyToAdd = Array.isArray(keyToAdd) ? keyToAdd : [keyToAdd]\n\n    if (keyToAdd.length > MAXIMUM_KEY_NUM)\n        throw new Error(`The maximum number of private keys that can be used in keyring is ${MAXIMUM_KEY_NUM}.`)\n    if (role >= KEY_ROLE.roleLast)\n        throw new Error(\n            `Unsupported role number. The role number should be less than ${KEY_ROLE.roleLast}. Please use 'caver.wallet.keyring.role'`\n        )\n\n    for (const keyString of keyToAdd) {\n        const key = keyString instanceof PrivateKey ? keyString : new PrivateKey(keyString)\n        keys[role].push(key)\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}